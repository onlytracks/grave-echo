{
  "id": "7b8784da",
  "title": "Phase 3.0: A* pathfinding for AI navigation",
  "tags": [
    "phase-3",
    "ai",
    "pathfinding",
    "foundation"
  ],
  "status": "pending",
  "created_at": "2026-02-15T06:10:56.734Z"
}

## Goal
Replace the naive `Math.sign(dx/dy)` movement in AI with A* pathfinding so entities
can navigate around walls, through corridors, and across complex map layouts. This is
a foundation for all AI patterns — without it, enemies get stuck on any obstacle
between them and their target.

## Read First
- `AGENTS.md` — project constraints, minimize dependencies

## Existing Code Context

### Current AI Movement (`src/ecs/systems/ai.ts`)
```typescript
// chargerBehavior, lines ~58-72
const stepX = dx !== 0 ? Math.sign(dx) : 0;
const stepY = dy !== 0 ? Math.sign(dy) : 0;

if (Math.abs(dx) >= Math.abs(dy)) {
  result = tryMove(world, map, entity, pos.x + stepX, pos.y, messages);
  if (result === "blocked" && stepY !== 0) {
    result = tryMove(world, map, entity, pos.x, pos.y + stepY, messages);
  }
} else { ... }
```

Moves toward target on the dominant axis, tries the other axis if blocked. No memory,
no lookahead. Gets stuck on L-shaped corridors, U-turns, any non-trivial geometry.

### Map Walkability (`src/map/game-map.ts`)
`map.isWalkable(x, y)` — checks tile walkability. Does NOT check entity collision.

### Entity Collision (`src/ecs/systems/movement.ts`)
`tryMove()` checks both tile walkability AND entity collision (Collidable components).
Hostile entities trigger attack instead of blocking.

### Map Size
Currently 120×80 (from Phase 2.2a). Viewport is ~50×30. A* needs to be efficient
at this scale but 120×80 = 9,600 tiles is trivial for A*.

## Requirements

### 1. A* Module
Create `src/pathfinding/astar.ts` with a standalone A* implementation:

```typescript
interface PathNode {
  x: number;
  y: number;
}

function findPath(
  startX: number,
  startY: number,
  goalX: number,
  goalY: number,
  isPassable: (x: number, y: number) => boolean,
  maxSearchNodes?: number,
): PathNode[] | null
```

Returns the path as an array of positions from start to goal (inclusive of goal,
exclusive of start), or null if no path exists.

**Key design**: the `isPassable` callback makes A* map-agnostic. The caller decides
what's passable — the pathfinder doesn't know about GameMap, World, or entities.

### 2. Algorithm Details
- **4-directional movement** (up/down/left/right) — matches game movement
- **Heuristic**: Manhattan distance (admissible for 4-directional)
- **Cost**: 1 per tile (uniform cost; future: terrain cost support)
- **Max search nodes**: default cap (e.g., 500) to prevent pathfinding across the
  entire map when no path exists. Return null if exceeded.
- **Binary heap** for the open set — don't use array.sort() per iteration

### 3. Binary Min-Heap
Implement a simple binary min-heap in `src/pathfinding/min-heap.ts` for the A* open
set. This keeps A* performant:

```typescript
class MinHeap<T> {
  constructor(compare: (a: T, b: T) => number)
  push(value: T): void
  pop(): T | undefined
  get size(): number
}
```

No external dependency. ~40 lines of code.

### 4. Passability Callback Construction
In the AI system, construct the passability callback from the map and world:

```typescript
function makePassable(
  world: World,
  map: GameMap,
  entity: Entity,
  goalEntity: Entity | null,
): (x: number, y: number) => boolean {
  // Cache entity positions for the current tick
  const blocked = new Set<string>();
  const blockers = world.query("Position", "Collidable");
  for (const other of blockers) {
    if (other === entity) continue;
    if (other === goalEntity) continue;  // goal entity is "passable" (we attack it)
    const pos = world.getComponent(other, "Position")!;
    const col = world.getComponent(other, "Collidable")!;
    if (col.blocksMovement) blocked.add(`${pos.x},${pos.y}`);
  }

  return (x: number, y: number) => {
    if (!map.isWalkable(x, y)) return false;
    return !blocked.has(`${x},${y}`);
  };
}
```

The goal entity is excluded from blocking so the path leads TO the target (last step
is the attack). Other entities block movement — AI paths around friendly entities.

### 5. Path Caching
AI entities don't need to recompute A* every step. Cache the path and follow it:

```typescript
interface AIControlled {
  pattern: "charger" | ...;
  targetEntity: number | null;
  // New fields:
  currentPath?: PathNode[];
  pathIndex?: number;
}
```

Recompute the path when:
- No cached path exists
- Target has moved since path was computed
- Entity is blocked (path is stale due to other entity movement)
- Every N turns as a fallback (e.g., every 3 turns)

Between recomputes, just follow the cached path step by step.

### 6. Update Charger Behavior
Replace the naive movement in `chargerBehavior()` with pathfinding:

```typescript
function chargerBehavior(world, map, entity, messages) {
  // ... existing target/goal resolution ...

  const path = getOrComputePath(world, map, entity, goalX, goalY);
  if (!path || path.length === 0) {
    // No path — blocked or unreachable
    messages.add(`[ai] ${name}: no path to target`, "debug");
    return;
  }

  // Follow path step by step
  while (turnActor.movementRemaining > 0 && !turnActor.hasActed) {
    const next = path[0];
    if (!next) break;

    const result = tryMove(world, map, entity, next.x, next.y, messages);
    if (result === "moved") {
      path.shift();  // consumed this step
    } else if (result === "attacked") {
      break;  // bumped target
    } else {
      // Path blocked by something new — invalidate and recompute next turn
      ai.currentPath = undefined;
      break;
    }
  }
}
```

### 7. Pathfinding Utilities for Future Patterns
Export helper functions that the archer, skulker, and patrol patterns will use:

```typescript
// Find path to a specific tile (not an entity)
function findPathToTile(world, map, entity, x, y): PathNode[] | null

// Find path AWAY from a position (for archer retreat)
function findRetreatPath(world, map, entity, awayFromX, awayFromY, steps): PathNode[] | null

// Find path to the nearest tile satisfying a condition (for skulker flanking)
function findPathToNearest(world, map, entity, candidates: PathNode[]): PathNode[] | null
```

These are wrappers around the core `findPath()` with different goal logic.

`findRetreatPath`: evaluate tiles at distance `steps` from the entity, pick the one
farthest from `awayFrom`, find a path to it.

`findPathToNearest`: run A* to each candidate, return the shortest valid path. Or
use a multi-target A* variant (expand from start, stop when any candidate is reached).

### 8. Performance Considerations
- 120×80 map = 9,600 tiles. A* with binary heap handles this in <1ms.
- Multiple AI entities each pathfinding: with 10-15 enemies, still <10ms total.
- `maxSearchNodes` cap (500) prevents degenerate cases.
- Cache paths to avoid recomputing every turn.
- Entity position blocking set is computed once per `processAI()` call and shared
  across all entities (pass it in rather than recomputing per entity).

### 9. No External Dependencies
Implement A* and the min-heap from scratch. This is ~100 lines total. No npm packages.

## File Structure
```
src/pathfinding/
  astar.ts        — A* algorithm, findPath()
  min-heap.ts     — Binary min-heap
  helpers.ts      — makePassable(), findRetreatPath(), findPathToNearest()
```

## Tests
- Unit test: findPath on open grid returns straight line
- Unit test: findPath navigates around a wall
- Unit test: findPath through L-shaped corridor
- Unit test: findPath returns null when no path exists (fully walled)
- Unit test: findPath returns null when maxSearchNodes exceeded
- Unit test: findPath excludes goal entity from blocking
- Unit test: findPath avoids other collidable entities
- Unit test: MinHeap push/pop maintains min ordering
- Unit test: MinHeap with custom comparator
- Unit test: findRetreatPath moves away from threat
- Unit test: charger with A* navigates corridor to reach player
- Manual: enemies no longer get stuck on corridor corners
- Manual: enemies path around rooms to reach player through doorways
- Manual: no visible performance degradation with multiple enemies pathing
- `bun test` passes

## Definition of Done
- A* pathfinding implemented with binary min-heap (no dependencies)
- `findPath()` works with arbitrary passability callback
- `makePassable()` constructs callback from World + GameMap state
- Charger behavior uses A* instead of naive dx/dy
- Path caching avoids unnecessary recomputation
- Helper functions exported for future AI patterns (retreat, nearest)
- Enemies navigate complex corridors and room layouts
- `bun test` passes
