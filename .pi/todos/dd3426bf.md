{
  "id": "dd3426bf",
  "title": "Comprehensive debug logging — make game fully replayable from logs",
  "tags": [
    "debug",
    "logging",
    "quality-of-life"
  ],
  "status": "done",
  "created_at": "2026-02-16T00:13:30.705Z"
}

## Goal
Every game-state-changing action should emit a debug message with entity IDs
and relevant state, so a run can be fully reconstructed from the log alone.

## What's Already Logged (verified from code)
- Entity spawns with position, type, pattern, intensity
- Dungeon generation (room count, tags, critical path)
- All movement (entity ID, from→to, moves remaining)
- Movement blocked (wall or entity, with positions)
- Combat (full stat breakdown, damage formula, HP before→after, crit flag)
- AI behavior decisions (pattern, action chosen, flanking/chasing/retreating)
- AI potion drinking (heal amount, HP state)
- Turn boundaries (turn number, entity move counts)
- Awareness state changes (idle↔alert, source entity + distance)
- FOW tile reveals (count of new tiles)
- Entity deaths + item drops (with notable/debug distinction)
- Defend stance activation + counterattack trigger

## What's Missing

### 1. Inventory Actions (src/ecs/systems/inventory.ts)
All functions emit gameplay messages only ("You pick up X"). Need debug messages with:

**pickup():**
```
[inv] Player picked up Iron Sword#7 at (5,3), weight 6→12/30
```
- Entity ID of picker and item, position, weight before→after/capacity

**drop():**
```
[inv] Player dropped Iron Sword#7 at (5,3), weight 12→6/30
```

**equip() / equipWeapon/Armor/Accessory:**
```
[inv] Player equipped Iron Sword#7 → weapon slot (was: Wand#3)
[inv] Player equipped Chainmail#9 → armor slot (was: empty)
[inv] Player auto-equipped Iron Sword#7 → weapon slot
```
- Distinguish auto-equip (from pickup) vs manual equip

**unequip():**
```
[inv] Player unequipped Iron Sword#7 from weapon slot
```

**useConsumable():**
```
[inv] Player used Healing Potion#5: heal 8, hp 12→20/20, charges 3→2
[inv] Player used Speed Potion#6: +1 speed for 5 turns, charges 2→1
```

**Consumable depleted + destroyed:**
```
[inv] Healing Potion#5 depleted (0 charges), destroyed
```

### 2. Buff System (src/ecs/systems/stats.ts)
**processBuffs() — buff expiry:**
```
[buff] Player: speed +1 expired (0 turns remaining)
[buff] ϛ#10: strength +2 expired (0 turns remaining)
```
Currently `processBuffs()` takes no messages parameter — needs to accept one.

**Buff application** (already in useConsumable but needs debug tag):
```
[buff] Player: +2 strength for 5 turns (from Strength Potion#6)
```

### 3. Weapon Swap (src/game.ts)
**Quick swap (2 weapons):**
```
[inv] Player swapped weapon: Iron Sword#7 → Short Bow#8 (secondary action)
```

**Popup swap (3+ weapons):**
```
[inv] Player swapped weapon: Iron Sword#7 → Short Bow#8 (secondary action, via popup)
```

Currently only emits gameplay "You swap to X".

### 4. Target Selection (src/ecs/systems/targeting.ts)
**cycleTarget():**
```
[target] Player target: none → ϛ#10 (dist=3)
[target] Player target: ϛ#10 → a#8 (dist=5)
```

**clearStaleTarget():**
```
[target] Player target ϛ#10 cleared: out of sight
[target] Player target ϛ#10 cleared: dead
```

### 5. Player Input (src/game.ts or src/ecs/systems/input.ts)
Log what action the player chose each step:
```
[input] Player: move south
[input] Player: attack (ranged)
[input] Player: pickup
[input] Player: defend
[input] Player: use item
[input] Player: swap weapon
[input] Player: cycle target
[input] Player: wait (.)
```

### 6. Ranged Attack Validation (src/ecs/systems/targeting.ts)
**attemptRangedAttack() failures:**
```
[combat] Player ranged attack failed: out-of-range (dist=9, weapon range=6)
[combat] Player ranged attack failed: no-los to ϛ#10 at (5,3)
```

### 7. Encumbrance Changes
After any pickup/drop that changes encumbrance bracket:
```
[inv] Player encumbrance: 0 → -1 speed (weight 16/30, 53%)
[inv] Player encumbrance: -1 → -2 speed (weight 24/30, 80%)
[inv] Player encumbrance: -2 → 0 (weight 10/30, 33%)
```

### 8. Death Details (src/ecs/systems/health.ts)
```
[death] ϛ#10 killed at (5,3), hp=0/12, killer=Player
[death] Player killed at (8,5), hp=0/20, killer=ϛ#10
```
Current: only gameplay "The ϛ dies!" — no entity ID, position, or killer info.

## Implementation Notes

### Message Signature Changes
- `processBuffs()` needs a `messages?: MessageLog` parameter
- `cycleTarget()` and `clearStaleTarget()` need `messages?: MessageLog`
- Other functions already accept messages, just need additional `.add()` calls

### Entity Name Helper
Use existing `entityName()` from `entity-name.ts` for consistent `name#id` format.
Import where needed.

### No New Categories
All new messages use `"debug"` category — they only appear in logs and debug panel,
never in the gameplay message log.

## Files to Change
- `src/ecs/systems/inventory.ts` — debug msgs for pickup, drop, equip, unequip, use, deplete
- `src/ecs/systems/stats.ts` — add messages param to processBuffs, log expiry
- `src/ecs/systems/targeting.ts` — debug msgs for cycleTarget, clearStaleTarget, validation failures
- `src/ecs/systems/health.ts` — enhanced death debug msg with position + killer
- `src/game.ts` — player input logging, weapon swap debug msgs, pass messages to processBuffs/targeting

## Tests
- Unit: pickup emits debug message with entity IDs and weight
- Unit: buff expiry emits debug message
- Unit: processBuffs accepts optional messages param (backward compatible)
- Manual: play a run, verify log contains enough detail to reconstruct every state change
- `bun test` passes

## Definition of Done
- Every state-changing action emits a debug message with entity IDs
- A run log contains enough information to reconstruct the full game sequence
- No gameplay messages changed — only new debug messages added
- `processBuffs`, `cycleTarget`, `clearStaleTarget` accept optional messages param
- `bun test` passes
