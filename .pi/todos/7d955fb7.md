{
  "id": "7d955fb7",
  "title": "Phase 0b.2: AI System + Enemy Entity (Charger)",
  "tags": [
    "phase-0b",
    "ai",
    "enemy"
  ],
  "status": "pending",
  "created_at": "2026-02-14T23:00:11.793Z",
  "assigned_to_session": "4070260b-dbff-4be6-82fb-855a2c3c3df1"
}

## Goal
Add an enemy entity with the Charger AI pattern that chases the player. Validates
the universal entity system — same components, same MovementSystem, different input source.

## Read First
- `AGENTS.md` — universal entity system constraint
- `docs/combat.md` — AI behavior patterns (Charger), entity action economy

## Dependencies
- Requires: Phase 0b.1 (Turn System, Health, Stats, AIControlled component)

## Requirements

### Create Enemy Entity
In `src/index.ts`, spawn one enemy entity with:
- Position: a floor tile away from the player (e.g., corner of the room)
- Renderable: `{ char: 'g', fg: 'red', bg: 'black' }` (goblin)
- Health: `{ current: 8, max: 8 }`
- Stats: `{ strength: 3, defense: 1, speed: 2 }`
- TurnActor: `{ hasActed: false, movementRemaining: 2 }`
- AIControlled: `{ pattern: 'charger', targetEntity: <player entity id> }`
- Collidable: `{ blocksMovement: true }`

### `src/ecs/systems/ai.ts` — AI System
Processes all entities with AIControlled + TurnActor + Position + Stats.

For each AI entity on its turn:
1. Reset TurnActor (movementRemaining = speed)
2. Execute behavior based on `pattern`:
   - **Charger:** move toward target entity using simple pathfinding
3. Use the **same MovementSystem** as the player to execute moves
4. Move up to movementRemaining tiles toward the target

### Charger Pathfinding (Simple)
- Calculate direction vector from enemy to target
- Prefer the axis with the greater distance (move horizontally if dx > dy, else vertically)
- If preferred direction is blocked (wall or entity), try the other axis
- If both blocked, don't move
- No A* needed yet — simple greedy approach. Enemies will get stuck on complex
  obstacles and that's acceptable for Phase 0b.

### Integration with Turn System
After the player's turn ends:
1. TurnSystem iterates all AIControlled entities
2. For each: AISystem decides moves, calls MovementSystem
3. After all AI entities act, new player turn begins
4. Re-render after all AI turns complete (player sees the result)

### The Universal Entity Proof
This task MUST demonstrate the universal entity principle:
- The goblin entity uses the SAME MovementSystem as the player
- The goblin is blocked by walls and other Collidable entities — same collision logic
- The only difference is: player movement comes from keyboard input,
  goblin movement comes from AISystem decisions
- There is NO code path that checks "is this the player?" in the MovementSystem

## Tests (`src/ecs/systems/__tests__/ai.test.ts`)
- Charger moves toward target when path is clear
- Charger stops when adjacent to target (will attack in Phase 0b.3)
- Charger tries alternate axis when preferred direction is blocked
- Charger doesn't move when completely blocked
- Charger respects movement points (speed 2 = max 2 tiles)
- Charger uses MovementSystem (blocked by walls, blocked by Collidable entities)

## Definition of Done
- A red 'g' appears on the grid
- After the player ends their turn, the goblin moves toward the player
- The goblin stops adjacent to the player (no combat yet — that's next)
- The goblin cannot walk through walls
- `bun test` passes all AI tests
- MovementSystem has ZERO player-specific code
