{
  "id": "d2490458",
  "title": "Phase 4.2a: SQLite foundation — database, migrations, repository pattern",
  "tags": [
    "phase-4",
    "persistence",
    "sqlite",
    "foundation"
  ],
  "status": "pending",
  "created_at": "2026-02-15T06:45:18.689Z"
}

## Goal
Establish the SQLite persistence layer using `bun:sqlite`. Database connection,
schema migrations, and the repository pattern so any system can persist data
through a typed interface. No SQL leaks outside `src/data/`.

## Read First
- `AGENTS.md` — repository pattern, no SQL outside src/data/, bun:sqlite only
- `docs/technical.md` — Data Layer section, table schemas, repository list

## Constraints
- `bun:sqlite` only — no ORM, no Drizzle, no better-sqlite3
- Synchronous API (bun:sqlite is sync, which is fine for a TUI game)
- No SQL outside `src/data/`
- Database file: `data/grave-echo.db` (gitignored)
- Repository pattern: typed methods, SQL hidden behind interfaces

## Requirements

### 1. Database Connection (`src/data/database.ts`)

```typescript
import { Database } from "bun:sqlite";

let db: Database | null = null;

export function getDatabase(path?: string): Database {
  if (!db) {
    db = new Database(path ?? "data/grave-echo.db");
    db.exec("PRAGMA journal_mode = WAL");
    db.exec("PRAGMA foreign_keys = ON");
    runMigrations(db);
  }
  return db;
}

export function closeDatabase(): void {
  db?.close();
  db = null;
}
```

WAL mode for performance. Foreign keys on for referential integrity.

### 2. Migration System

Simple version-based migrations. No migration library needed.

```typescript
interface Migration {
  version: number;
  name: string;
  up: string;  // SQL to apply
}

const MIGRATIONS: Migration[] = [
  {
    version: 1,
    name: "initial_schema",
    up: `
      CREATE TABLE IF NOT EXISTS schema_version (
        version INTEGER PRIMARY KEY
      );

      CREATE TABLE IF NOT EXISTS skeletons (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        stats_json TEXT NOT NULL,
        equipped_slots_json TEXT NOT NULL,
        death_turn INTEGER NOT NULL,
        kill_count INTEGER NOT NULL,
        runs_ago INTEGER NOT NULL DEFAULT 0,
        created_at TEXT NOT NULL DEFAULT (datetime('now'))
      );

      CREATE TABLE IF NOT EXISTS skeleton_items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        skeleton_id INTEGER NOT NULL REFERENCES skeletons(id) ON DELETE CASCADE,
        item_index INTEGER NOT NULL,
        name TEXT NOT NULL,
        weight REAL NOT NULL,
        rarity TEXT NOT NULL,
        glyph TEXT NOT NULL,
        color TEXT NOT NULL,
        weapon_json TEXT,
        armor_json TEXT,
        accessory_json TEXT,
        consumable_json TEXT
      );

      CREATE TABLE IF NOT EXISTS game_flags (
        key TEXT PRIMARY KEY,
        value TEXT NOT NULL
      );
    `,
  },
];

function runMigrations(db: Database): void {
  db.exec(`CREATE TABLE IF NOT EXISTS schema_version (version INTEGER PRIMARY KEY)`);
  const row = db.query("SELECT MAX(version) as v FROM schema_version").get() as { v: number | null };
  const currentVersion = row?.v ?? 0;

  for (const migration of MIGRATIONS) {
    if (migration.version > currentVersion) {
      db.exec(migration.up);
      db.exec(`INSERT INTO schema_version (version) VALUES (${migration.version})`);
    }
  }
}
```

Future tables (stash, player_stats, merchant, etc.) are added as new migrations.
Each migration only runs once. Version tracked in `schema_version` table.

### 3. Repository Interface Pattern

```typescript
// src/data/repository.ts
export interface Repository {
  // marker interface — each repo defines its own methods
}
```

Each repository:
- Takes a `Database` in its constructor
- Prepares statements once (bun:sqlite `db.query()` returns reusable prepared statements)
- Exposes typed methods, no raw SQL in return types
- Handles JSON serialization/deserialization for complex fields

### 4. Skeleton Repository (`src/data/skeleton-repository.ts`)

This is the first real consumer, planned for Phase 4.2b. Define the interface here
so the structure is established:

```typescript
export class SkeletonRepository {
  constructor(private db: Database) {}

  saveRecord(record: SkeletonRecord): number;      // returns skeleton id
  loadAll(): SkeletonRecord[];                       // all records, newest first
  ageAll(): void;                                    // increment runs_ago
  deleteOldest(keepCount: number): void;            // enforce 10 cap
  deleteAll(): void;                                 // for testing/reset
}
```

JSON columns: `stats_json`, `equipped_slots_json`, `weapon_json`, etc. are
serialized via `JSON.stringify`/`JSON.parse`. bun:sqlite handles TEXT columns fine.

### 5. Game Flags Repository (`src/data/flags-repository.ts`)

Simple key-value store for game state flags:

```typescript
export class FlagsRepository {
  constructor(private db: Database) {}

  get(key: string): string | null;
  set(key: string, value: string): void;
  getBoolean(key: string): boolean;    // "true"/"false" convenience
  setBoolean(key: string, value: boolean): void;
  delete(key: string): void;
}
```

Used for: `hub_discovered`, `tutorial_completed`, etc.

### 6. Game Integration

```typescript
// src/game.ts
import { getDatabase, closeDatabase } from "./data/database.ts";

export class Game {
  constructor(...) {
    // Database initializes on first access (lazy)
  }

  async run(): Promise<void> {
    try {
      // ... existing game loop ...
    } finally {
      closeDatabase();
    }
  }
}
```

The database is lazily initialized on first repository access. Closed cleanly
on game exit.

### 7. File Structure
```
src/data/
  database.ts           — connection, PRAGMA, migration runner
  migrations.ts         — migration definitions array
  skeleton-repository.ts — skeleton CRUD (interface + impl)
  flags-repository.ts   — key-value game flags
data/
  .gitkeep              — ensure directory exists
```

### 8. Gitignore
Add to `.gitignore`:
```
data/*.db
data/*.db-wal
data/*.db-shm
```

### 9. Testing Utilities
For tests, use `:memory:` database:

```typescript
export function createTestDatabase(): Database {
  const db = new Database(":memory:");
  db.exec("PRAGMA foreign_keys = ON");
  runMigrations(db);
  return db;
}
```

This avoids file I/O in tests and gives each test a clean database.

## What This Does NOT Include
- Stash repository (needs Hub — future)
- Player stats/XP repository (needs progression system — future)
- Merchant repository (needs merchant — future)
- Definition tables (read-only game data — future, currently hardcoded factories)
- Actual skeleton persistence (that's 4.2b)

This todo is purely the foundation: connect, migrate, repository pattern, first
two repositories (skeletons + flags) ready to use.

## Tests
- Unit test: database creates and runs migrations
- Unit test: running migrations twice is idempotent
- Unit test: schema_version tracks applied migrations
- Unit test: FlagsRepository get/set/getBoolean/delete
- Unit test: SkeletonRepository saveRecord/loadAll round-trips data correctly
- Unit test: SkeletonRepository ageAll increments runs_ago
- Unit test: SkeletonRepository deleteOldest keeps N newest
- Unit test: JSON fields serialize/deserialize complex objects (weapon stats, etc.)
- Unit test: in-memory test database works for all repos
- `bun test` passes

## Definition of Done
- `bun:sqlite` database connection with WAL mode and foreign keys
- Version-based migration system (idempotent, tracks schema_version)
- Initial schema: skeletons, skeleton_items, game_flags tables
- SkeletonRepository with full CRUD + age + cap enforcement
- FlagsRepository with key-value get/set
- Test utility for in-memory database
- No SQL outside `src/data/`
- `data/*.db` gitignored
- `bun test` passes
