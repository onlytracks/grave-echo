{
  "id": "4743c667",
  "title": "Consumable quick-select popup — 'u' opens picker instead of auto-using first consumable",
  "tags": [
    "gameplay",
    "ui",
    "items",
    "consumables"
  ],
  "status": "done",
  "created_at": "2026-02-15T21:43:35.207Z"
}

## Goal
Pressing `u` currently auto-uses the first consumable found in inventory — the
player has no choice. Replace this with a quick-select popup: `u` opens a small
overlay listing consumables, player presses a number key (1-9) or arrows+Enter
to pick one. Escape cancels without using a turn.

## Current Behavior (broken)
In `src/ecs/systems/input.ts` line ~88:
```typescript
const consumableId = inventory.items.find((id) =>
  world.hasComponent(id, "Consumable"),
);
```
Blindly grabs the first consumable. No feedback about what it is before using it.

## New Behavior

### Quick-Select Popup
1. Player presses `u`
2. If no consumables in inventory → message "No consumables." and return (no state change)
3. If consumables exist → enter `GameState.UseItem` state, render popup overlay
4. Popup shows numbered list of consumables with charges and brief effect description
5. Player presses number key (1-9) to use that consumable, or Escape to cancel
6. Using a consumable is a **primary action** (ends turn) — same as current behavior
7. Canceling returns to `GameState.Running` with no turn cost

### Popup Rendering
Follow the same pattern as inventory screen and death popup — fill background
with black cells first to prevent UI bleed-through, then draw box and content.

```
┌─ Use Item ─────────────┐
│                         │
│  1. Health Potion  x3   │
│  2. Strength Elixir x1  │
│  3. Speed Draught  x2   │
│                         │
│  [1-3] use  [Esc] cancel│
└─────────────────────────┘
```

Show: number, item name, charges remaining. Optionally show effect
(e.g., "+15 HP" or "+3 str 5t") if space allows.

Center the popup in the game grid region (same as inventory screen).

### Size
- Width: 30 chars or fit to longest item name + padding
- Height: consumable count + 4 (title, blank, items, footer)
- Capped to game grid region bounds

## Implementation

### 1. New GameState
Add `UseItem` to the `GameState` enum in `src/game.ts`:
```typescript
enum GameState {
  Running,
  Dead,
  Quit,
  Inventory,
  UseItem,  // new
}
```

### 2. UseItem Screen State
Create `src/ui/use-item-screen.ts`:

```typescript
export interface UseItemScreenState {
  consumables: Entity[];  // filtered list of consumable items in inventory
}

export function createUseItemScreenState(
  world: World,
  player: Entity,
): UseItemScreenState | null {
  const inventory = world.getComponent(player, "Inventory");
  if (!inventory) return null;
  const consumables = inventory.items.filter(id =>
    world.hasComponent(id, "Consumable")
  );
  if (consumables.length === 0) return null;
  return { consumables };
}

export function renderUseItemScreen(
  renderer: Renderer,
  world: World,
  state: UseItemScreenState,
  region: Region,
): void {
  // Calculate popup bounds
  // Fill background with black cells (prevent bleed-through!)
  // Draw box with "Use Item" title
  // List each consumable: number, name, charges, effect hint
  // Footer: [1-N] use  [Esc] cancel
}

export function handleUseItemKey(
  key: number,
  state: UseItemScreenState,
): Entity | null | "cancel" {
  // Escape (0x1b) → "cancel"
  // 0x31-0x39 (1-9) → return consumables[key-1] or null if out of range
}
```

### 3. Game Integration
In `src/game.ts`:

```typescript
private useItemScreen: UseItemScreenState | null = null;

private openUseItem(): void {
  const player = this.getPlayerEntity();
  if (!player) return;
  const state = createUseItemScreenState(this.world, player);
  if (!state) {
    this.messages.add("No consumables in inventory.");
    return;
  }
  this.useItemScreen = state;
  this.state = GameState.UseItem;
}

private closeUseItem(): void {
  this.useItemScreen = null;
  this.state = GameState.Running;
}
```

In `playUntilDeath()` loop:
- Add `GameState.UseItem` to the while condition
- When in UseItem state, wait for input, handle key selection
- On valid selection: call `useConsumable()`, set `hasActed=true`, close popup
- On cancel: close popup, no turn cost

In `render()`:
- After other panels, if `state === GameState.UseItem`, render the popup

### 4. Remove Auto-Use from Input System
In `src/ecs/systems/input.ts`, the `useItem` event handler currently auto-selects
and uses. Change it to just return a signal that the game loop should open the
popup. Or simpler: handle `u` in `game.ts` directly (like `i` for inventory)
instead of routing through `handlePlayerInput`.

Looking at the code, `i` for inventory is already handled in `game.ts` before
`handlePlayerInput`:
```typescript
if (event.type === "inventory") {
  this.openInventory();
  continue;
}
```

Do the same for `useItem`:
```typescript
if (event.type === "useItem") {
  this.openUseItem();
  continue;
}
```

Then remove the `useItem` handler from `src/ecs/systems/input.ts` — consumption
is triggered from game.ts after popup selection, calling `useConsumable()` directly.

### 5. Background Fill (Critical)
The popup MUST fill its area with black cells before drawing the box, identical to
inventory screen and death popup. Without this, the game grid bleeds through:

```typescript
for (let y = boxY; y < boxY + boxH; y++) {
  for (let x = boxX; x < boxX + boxW; x++) {
    renderer.drawCell(x, y, " ", "white", "black");
  }
}
renderer.drawBox(boxX, boxY, boxW, boxH, "Use Item");
```

### 6. Turn Economy
Using a consumable = primary action (ends turn). This is unchanged from current.
The popup is just UI — it doesn't cost anything to open/close it.

Check `turnActor.hasActed` before opening the popup. If already acted, show
"Already acted this turn." and don't open.

## Universal Design
The `useConsumable()` function in `src/ecs/systems/inventory.ts` already works for
any entity. The popup is player UI — AI entities call `useConsumable()` directly
in their AI logic (future). No special-case code needed.

## Files to Change
- `src/game.ts` — add UseItem state, open/close/handle methods, render hook
- `src/ui/use-item-screen.ts` — new file: state, render, input handling
- `src/ecs/systems/input.ts` — remove `useItem` auto-use handler
- `src/input/input-handler.ts` — `useItem` event type stays as-is

## Edge Cases
- 0 consumables: message, no popup
- 1 consumable: still show popup (confirm before using)
- Player already acted: message, no popup
- Consumable charge reaches 0 after use: item destroyed (existing behavior)
- 10+ consumables: only show first 9 (weight system makes this very unlikely)

## Tests
- Unit test: createUseItemScreenState returns null when no consumables
- Unit test: createUseItemScreenState filters to only Consumable items
- Unit test: handleUseItemKey returns correct entity for valid number
- Unit test: handleUseItemKey returns "cancel" for Escape
- Unit test: handleUseItemKey returns null for out-of-range number
- Manual: `u` opens popup, shows consumables with charges
- Manual: number key uses correct consumable, ends turn
- Manual: Escape cancels without turn cost
- Manual: no UI bleed-through behind popup
- `bun test` passes

## Definition of Done
- `u` opens quick-select popup listing consumables
- Number keys (1-9) select and use a consumable
- Escape cancels without turn cost
- Using a consumable is a primary action (ends turn)
- Popup has black background fill (no bleed-through)
- Auto-use removed from input system
- `bun test` passes
