{
  "id": "8617a61d",
  "title": "Phase 4.2b: Skeleton persistence — SkeletonStore backed by SQLite",
  "tags": [
    "phase-4",
    "persistence",
    "sqlite",
    "skeletons"
  ],
  "status": "pending",
  "created_at": "2026-02-15T06:45:41.548Z"
}

## Goal
Replace the in-memory `SkeletonStore` (from Phase 4.1) with a SQLite-backed
implementation using the `SkeletonRepository` (from Phase 4.2a). Skeletons now
survive across game sessions — close the game, reopen, your echoes are waiting.

## Dependencies
- **TODO-5cb36ad2** (Phase 4.1) — Skeleton echo system (in-memory) must exist first
- **TODO-d2490458** (Phase 4.2a) — SQLite foundation, SkeletonRepository

## What Changes

### 1. SkeletonStore Becomes a Thin Wrapper
Currently `SkeletonStore` holds `SkeletonRecord[]` in memory. Replace the backing
store with `SkeletonRepository`:

```typescript
// src/skeleton/skeleton-store.ts
import { SkeletonRepository } from "../data/skeleton-repository.ts";

export class SkeletonStore {
  private repo: SkeletonRepository;
  private readonly MAX_SKELETONS = 10;

  constructor(repo: SkeletonRepository) {
    this.repo = repo;
  }

  add(record: SkeletonRecord): void {
    this.repo.saveRecord(record);
    this.repo.deleteOldest(this.MAX_SKELETONS);
  }

  getAll(): SkeletonRecord[] {
    return this.repo.loadAll();
  }

  ageAll(): void {
    this.repo.ageAll();
  }
}
```

The in-memory cache is gone. All reads/writes go through the repository.
bun:sqlite is synchronous so there's no async complexity — calls look identical
to the in-memory version.

### 2. Game Integration Update
```typescript
// src/game.ts
import { getDatabase } from "./data/database.ts";
import { SkeletonRepository } from "./data/skeleton-repository.ts";

export class Game {
  private skeletonStore: SkeletonStore;

  constructor(...) {
    const db = getDatabase();
    this.skeletonStore = new SkeletonStore(new SkeletonRepository(db));
  }
}
```

The rest of Game doesn't change — `skeletonStore.add()`, `skeletonStore.getAll()`,
`skeletonStore.ageAll()` all have the same interface.

### 3. Data Round-Trip Validation
The critical part: `SkeletonRecord` → SQLite rows → `SkeletonRecord` must be
lossless. The `SkeletonItemRecord` contains nested objects (Weapon, Armor, etc.)
stored as JSON text columns. Verify:

- Weapon stats (damage, range, weaponType, attackType, defenseBonus)
- Armor stats (defense, speedPenalty, armorType)
- Accessory bonuses array
- Consumable (effectType, power, duration, charges, maxCharges)
- Rarity strings
- Equipment slot index mapping

### 4. First-Run Experience
On first launch, database is empty — `getAll()` returns `[]`. No skeletons spawn.
Identical to current in-memory behavior on first run. After first death, skeleton
is persisted and survives restart.

### 5. Database Location
`data/grave-echo.db` relative to project root. Create `data/` directory if it
doesn't exist (handled by database.ts from 4.2a).

## Files to Change
- `src/skeleton/skeleton-store.ts` — replace in-memory array with SkeletonRepository
- `src/game.ts` — construct SkeletonStore with repository

## Tests
- Unit test: save skeleton, close/reopen database, load returns same skeleton
- Unit test: round-trip all item types (weapon, armor, accessory, consumable)
- Unit test: ageAll persists incremented runs_ago
- Unit test: 11th skeleton triggers deleteOldest, only 10 remain
- Unit test: empty database returns empty array
- Integration test: full cycle — create game, die, restart, skeleton spawns from DB
- `bun test` passes

## Definition of Done
- SkeletonStore backed by SkeletonRepository (SQLite)
- Skeletons survive game restart
- All SkeletonRecord fields round-trip through SQLite correctly
- 10 skeleton cap enforced in database
- Existing skeleton spawning/degradation unchanged
- `bun test` passes
