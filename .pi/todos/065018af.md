{
  "id": "065018af",
  "title": "Phase 0a.5: Game Loop + Integration",
  "tags": [
    "phase-0a",
    "gameloop",
    "integration"
  ],
  "status": "done",
  "created_at": "2026-02-14T22:59:28.474Z"
}

## Goal
Wire everything together into a running game: ECS + map + input + movement + rendering
in a main game loop. The player (@) moves around a room.

## Read First
- `AGENTS.md` — project constraints
- `docs/technical.md` — game loop architecture, project structure

## Dependencies
- Requires: ALL Phase 0a tasks completed (0a.1 through 0a.4)

## Requirements

### `src/game.ts` — Game State Machine
Manages high-level game state. For Phase 0a, there's only one state: `gameplay`.
```typescript
enum GameState {
  Gameplay,
  Quitting,
}
```
- Holds references to the ECS World, GameMap, and Renderer
- Handles state transitions (gameplay → quitting)
- Designed to support future states (inventory, menu, merchant) without rewriting

### `src/index.ts` — Entry Point
The main function that:
1. Creates the ECS World
2. Creates the hardcoded GameMap (from room-builder)
3. Creates the player entity at a walkable position:
   - Position: center of the room
   - Renderable: `{ char: '@', fg: 'white', bg: 'black' }`
   - PlayerControlled: tag
   - Collidable: `{ blocksMovement: true }`
4. Initializes the Renderer (AnsiRenderer)
5. Enters the game loop

### Game Loop
```
while (state !== Quitting) {
  render(world, map, renderer)    // Draw map + entities
  input = await waitForInput()     // Block until keypress
  if (input.type === 'quit') → transition to Quitting
  if (input.type === 'move') → InputSystem → MovementSystem
}
renderer.shutdown()                // Clean terminal restore
```

This is a **blocking input loop**, not a frame-based loop. The game only redraws when
something happens (a key is pressed). This is correct for turn-based — no wasted CPU.

### Rendering Order
1. Renderer.clear()
2. Draw map tiles (floor, walls)
3. Draw entities with Position + Renderable on top of tiles
4. Draw a simple status line below the grid: "Arrow keys to move, Q to quit"
5. Renderer.flush()

### Graceful Shutdown
- On quit (Q or Escape): shutdown renderer, restore terminal, exit cleanly
- On crash/uncaught exception: ensure renderer.shutdown() is called (try/finally or
  process event handlers) so the terminal is never left in raw mode
- Handle SIGINT (Ctrl+C) — shutdown cleanly

### Run Command
Add to package.json scripts:
```json
"start": "bun run src/index.ts"
```

## No Tests For This Task
This is integration — verified by running `bun run start` and visually confirming:
- Grid renders with walls and floor
- @ symbol appears in the center
- Arrow keys move @ around
- @ stops at walls
- Q quits cleanly without garbling the terminal

## Definition of Done
- `bun run start` launches the game
- Player (@) renders on a grid with walls
- Arrow keys move the player, walls block movement
- Q/Escape quits cleanly, terminal is restored
- No external dependencies added
