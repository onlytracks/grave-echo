{
  "id": "2a03ea80",
  "title": "Phase 3.1: Ranged combat — targeting, ranged attacks, weapon ranges",
  "tags": [
    "phase-3",
    "combat",
    "ranged",
    "targeting"
  ],
  "status": "done",
  "created_at": "2026-02-15T05:25:48.201Z"
}

## Goal
Add ranged combat: Tab cycles through visible hostile entities to select a target,
Space fires the equipped weapon at the selected target if in range and LOS. Melee
weapons still use bump-to-attack. Reach weapons (spears) attack 1-2 tiles in cardinal
directions. Ranged weapons (bows, staves) attack any visible target within range.
No ammo tracking.

## Read First
- `AGENTS.md` — universal entity system, no special-case code
- `docs/combat.md` — weapon categories, ranges, targeting system, attack types

## Existing Code Context

### Weapon Component (`src/ecs/components.ts`)
```typescript
interface Weapon {
  damage: number;
  range: number;
  weaponType: "sword" | "bow";
}
```
Only two weapon types exist. Range field exists but is unused — all combat is
bump-to-attack via `tryMove()` collision.

### Combat (`src/ecs/systems/combat.ts`)
`attack(world, attacker, defender, messages)` — applies damage, marks turn as acted.
Called only from `tryMove()` when bumping into a hostile. No range or LOS check.

### Movement (`src/ecs/systems/movement.ts`)
`tryMove()` handles bump-to-attack: if target tile has a hostile, calls `attack()`.
This is the only attack path currently.

### Input (`src/ecs/systems/input.ts` + `src/input/input-handler.ts`)
No Tab or Space handling. InputEvent has no `"target"` or `"attack"` types.

### LOS (`src/ecs/systems/sensory.ts`)
`hasLineOfSight(map, x0, y0, x1, y1)` — Bresenham raycasting, already exported.
`computeVisibleTiles()` — returns Set of "x,y" strings for all visible tiles.

### No Target State
No component or game state tracks the player's selected target.

## Requirements

### 1. Expand Weapon Types
Update the Weapon component to support the weapon categories from `docs/combat.md`:

```typescript
type WeaponType = "sword" | "axe" | "mace" | "spear" | "halberd" | "bow" | "crossbow" | "staff" | "wand";
type AttackType = "melee" | "reach" | "ranged";

interface Weapon {
  damage: number;
  range: number;
  weaponType: WeaponType;
  attackType: AttackType;
}
```

Attack type determines targeting rules:
- **melee** (range 1): bump-to-attack only, no change from current behavior
- **reach** (range 2): can attack entities 1-2 tiles away in cardinal directions
- **ranged** (range 3-8): can attack any visible entity within range via LOS

### 2. Target Selection Component
Add a `TargetSelection` component to track which entity is currently targeted:

```typescript
interface TargetSelection {
  targetEntity: number | null;
}
```

Add to ComponentMap. The player entity gets this component. AI entities don't need
it — they select targets via their AI behavior.

This is NOT in the Awareness component because targeting is a UI/input concern, not
a sensing concern. AI entities pick targets in their behavior code.

### 3. Tab — Cycle Targets
Add `"cycleTarget"` to InputEvent. Map Tab key (0x09) in `parseInput()`.

When Tab is pressed:
1. Get all visible hostile entities (use player's current `visibleTiles` set)
2. Sort by distance from player (nearest first) for consistent ordering
3. If no current target, select the nearest
4. If current target exists, select the next one in the list (wrap around)
5. If current target is dead or no longer visible, clear it and select nearest

Tab is a free action — does not consume any part of the turn economy (per `docs/combat.md`).

### 4. Space — Attack Selected Target
Add `"attack"` to InputEvent. Map Space key (0x20) in `parseInput()`.

When Space is pressed:
1. Check player has a selected target (`TargetSelection.targetEntity`)
2. Check target is still alive and has Position
3. Get player's equipped weapon (or unarmed: melee, range 1, low damage)
4. Check attack type rules:
   - **melee**: target must be adjacent (Manhattan distance ≤ 1)
   - **reach**: target must be within range AND in a cardinal direction from player
     (same row or same column, dx=0 or dy=0)
   - **ranged**: target must be within range AND `hasLineOfSight()` returns true
5. If valid, call `attack(world, player, target, messages)`
6. If out of range: message "Target out of range" (gameplay message)
7. If no LOS: message "No line of sight" (gameplay message)

Attack is a primary action — `turnActor.hasActed = true` (already handled in `attack()`).

### 5. Bump-to-Attack Still Works
`tryMove()` continues to handle bump-to-attack for melee. Nothing changes for melee
weapons. The player can either bump into enemies or Tab+Space to attack adjacent targets.

For reach/ranged weapons, bump-to-attack should still work at range 1 (you can stab
someone with a spear or whack them with a bow). The bump path already calls `attack()`
which doesn't check range.

### 6. Target Highlight on Grid
In `src/renderer/panels/game-grid.ts`, render the selected target's tile with a
distinct background color (e.g., dark red or highlighted border). The target entity
should stand out visually.

Also draw a line-of-sight indicator: dim highlight on tiles between player and target
to show the attack path. This helps the player understand LOS.

### 7. TargetInfo Panel
The TargetInfo panel (created in Phase 2.1 but unpopulated) should now display:
- Target name
- Target HP (current/max)
- Target weapon and attack type
- Distance from player
- Whether attack is valid (in range + LOS)

Update `src/renderer/panels/target-info.ts` to read from `TargetSelection`.

### 8. Auto-Clear Stale Targets
Each turn, before input processing, verify the selected target is still valid:
- Entity still exists
- Entity still has Position
- Entity is still visible (in player's visible tiles)
- Entity is still hostile

If any check fails, clear `TargetSelection.targetEntity` to null.

### 9. Reach Weapon Rules
Reach weapons (spear, halberd) have a unique constraint: they only hit targets in
cardinal directions. This is because you thrust a spear — you don't swing it around
corners.

Check: `(targetPos.x === playerPos.x || targetPos.y === playerPos.y)` AND
Manhattan distance ≤ weapon.range AND `hasLineOfSight()`.

If the target is adjacent (distance 1), reach weapons work like melee — no cardinal
restriction.

### 10. AI Ranged Attacks
AI entities with ranged weapons should use ranged attacks instead of always chasing.
Update `src/ecs/systems/ai.ts`:

For the existing charger pattern (and future archer pattern):
1. Check if target is within weapon range AND has LOS
2. If yes, attack from current position (don't move closer)
3. If no, move toward target (existing behavior)

This means an enemy with a bow will shoot the player from across the room instead of
walking up to melee range. The Archer AI pattern (future) will additionally try to
maintain distance.

For now, just make the charger pattern smart enough to attack at range if it has a
ranged weapon. The behavior is: "get in range, then attack." A charger with a sword
gets to melee range. A charger with a bow stops at bow range.

### 11. Unarmed Fallback
If an entity has no weapon equipped, they attack unarmed:
- attackType: "melee"
- range: 1
- damage: use `stats.strength` directly (already the case in `attack()`)

### 12. Spawn Ranged Weapons
Add a bow or staff to the dungeon item spawns so ranged combat can be tested.
Place a ranged weapon in an early room. Update existing weapon spawning.

## Edge Cases
- **Target dies mid-turn** (killed by something else): auto-clear on next input
- **Player moves out of LOS after targeting**: attack fails with "No line of sight"
- **Enemy moves out of range between Tab and Space**: attack fails with "Out of range"
- **Reach weapon diagonal**: spear can't hit diagonal targets at range 2 (cardinal only)
- **Melee weapon + Space**: works if target is adjacent, fails otherwise
- **Multiple enemies at same distance**: Tab ordering is stable (sort by entity ID as tiebreaker)

## Tests
- Unit test: Tab cycles through visible hostiles in distance order
- Unit test: Tab wraps around to first target after last
- Unit test: Space with ranged weapon + valid LOS + in range → attack succeeds
- Unit test: Space with ranged weapon + no LOS → attack fails
- Unit test: Space with ranged weapon + out of range → attack fails
- Unit test: Space with melee weapon + non-adjacent target → attack fails
- Unit test: Reach weapon hits cardinal target at range 2
- Unit test: Reach weapon fails on diagonal target at range 2
- Unit test: Bump-to-attack still works for all weapon types
- Unit test: Stale target auto-cleared when entity dies
- Unit test: AI with ranged weapon attacks at range instead of closing
- Manual: Tab highlights target on grid
- Manual: TargetInfo panel shows target details
- Manual: LOS line visible between player and target
- Manual: Ranged combat feels responsive — Tab, Space, done
- Manual: AI enemies with bows shoot from distance

## Definition of Done
- Weapon types expanded (melee/reach/ranged attack types)
- Tab cycles visible hostile targets (free action)
- Space attacks selected target respecting range + LOS + weapon type
- Bump-to-attack unchanged for melee
- Reach weapons enforce cardinal direction at range 2+
- Target highlighted on game grid
- TargetInfo panel populated with target data
- AI entities use ranged attacks when appropriate
- At least one ranged weapon spawns for testing
- `bun test` passes
