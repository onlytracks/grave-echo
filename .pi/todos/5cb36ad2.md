{
  "id": "5cb36ad2",
  "title": "Phase 4.1: Skeleton echo system (in-memory)",
  "tags": [
    "phase-4",
    "meta-progression",
    "death",
    "skeletons"
  ],
  "status": "pending",
  "created_at": "2026-02-15T06:26:07.464Z"
}

## Goal
When the player dies, snapshot their equipment and stats into a "skeleton record."
On the next run, spawn that skeleton as a hostile entity in the dungeon carrying
degraded versions of the player's gear. Up to 10 skeletons persist (in memory)
across runs within a session. Oldest skeletons degrade further. This is the core
"Grave Echo" mechanic â€” death has consequences AND rewards.

## Read First
- `AGENTS.md` â€” universal entity system, no special-case code
- `docs/core-loop.md` â€” Skeleton System section (10 cap, degradation, placement)

## Dependencies
- **TODO-c2d6cdd4** (enemy loot drops) â€” skeletons must drop their gear when killed

## Existing Code Context

### Game Loop (`src/game.ts`)
```typescript
async run(): Promise<void> {
  while (true) {
    this.initNewRun();
    await this.playUntilDeath();
    if (this.state === GameState.Quit) break;
    const action = await this.showGameOver();
    if (action === "quit") break;
    // loops back to initNewRun â€” this is where skeletons spawn
  }
}
```

The `run()` loop already supports multiple runs per session. Skeleton records
need to survive across iterations of this loop (stored on the Game instance).

### Death Screen (`showGameOver()`)
Shows turns survived and enemies slain. Could be enhanced to show "Skeleton left
behind" but that's optional polish.

### Entity Creation
Enemies created via factory functions in `src/enemies/enemy-factory.ts`.
Items created via factories in `src/items/item-factory.ts`.

### Components Available
- `Item`, `Weapon`, `Armor`, `Accessory`, `Consumable` â€” full item component set
- `Renderable`, `Position`, `Health`, `Stats`, `Inventory`, `Equipment`
- `AIControlled` â€” skeletons will use existing AI patterns
- `Faction` â€” skeletons should be `"enemy"` faction

## Requirements

### 1. Skeleton Record Type
Create `src/skeleton/skeleton-record.ts`:

```typescript
interface SkeletonItemRecord {
  name: string;
  weight: number;
  rarity: Item["rarity"];
  glyph: string;
  color: string;
  // Slot-specific data (only one populated)
  weapon?: Omit<Weapon, never>;
  armor?: Omit<Armor, never>;
  accessory?: Omit<Accessory, never>;
  consumable?: Omit<Consumable, never>;
}

interface SkeletonRecord {
  items: SkeletonItemRecord[];
  equippedSlots: {
    weapon: number | null;   // index into items[]
    armor: number | null;
    accessory1: number | null;
    accessory2: number | null;
  };
  stats: { strength: number; defense: number; speed: number; maxHealth: number };
  deathTurn: number;
  killCount: number;
  runsAgo: number;  // incremented each run, used for degradation
}
```

This is a plain data snapshot â€” no entity references. Serializable (future SQLite).

### 2. Skeleton Store
Create `src/skeleton/skeleton-store.ts`:

```typescript
class SkeletonStore {
  private records: SkeletonRecord[] = [];  // newest first
  private readonly MAX_SKELETONS = 10;

  add(record: SkeletonRecord): void;  // pushes to front, trims oldest
  getAll(): SkeletonRecord[];
  ageAll(): void;  // increment runsAgo on all records (call at run start)
}
```

Stored on the `Game` instance, survives across `initNewRun()` calls.

### 3. Capture Snapshot on Death
In `Game`, when player dies (before `showGameOver()`), capture a skeleton record:

```typescript
private captureSkeletonRecord(): SkeletonRecord | null {
  const player = this.getPlayerEntity();
  if (!player) return null;

  const pos = this.world.getComponent(player, "Position");
  const inv = this.world.getComponent(player, "Inventory");
  const equip = this.world.getComponent(player, "Equipment");
  const stats = this.world.getComponent(player, "Stats");
  if (!inv || !stats) return null;

  // Snapshot each item's components into SkeletonItemRecord
  const items: SkeletonItemRecord[] = [];
  for (const itemId of inv.items) {
    const item = this.world.getComponent(itemId, "Item");
    const rend = this.world.getComponent(itemId, "Renderable");
    if (!item || !rend) continue;
    items.push({
      name: item.name,
      weight: item.weight,
      rarity: item.rarity,
      glyph: rend.char,
      color: rend.color,
      weapon: this.world.getComponent(itemId, "Weapon") ?? undefined,
      armor: this.world.getComponent(itemId, "Armor") ?? undefined,
      accessory: this.world.getComponent(itemId, "Accessory") ?? undefined,
      consumable: this.world.getComponent(itemId, "Consumable") ?? undefined,
    });
  }

  // Map equipment entity IDs to item[] indices
  const indexOf = (eid: number | null) => {
    if (eid === null) return null;
    return inv.items.indexOf(eid);
  };

  return {
    items,
    equippedSlots: {
      weapon: indexOf(equip?.weapon ?? null),
      armor: indexOf(equip?.armor ?? null),
      accessory1: indexOf(equip?.accessory1 ?? null),
      accessory2: indexOf(equip?.accessory2 ?? null),
    },
    stats: { strength: stats.strength, defense: stats.defense, speed: stats.speed, maxHealth: stats.maxHealth },
    deathTurn: this.turnCounter,
    killCount: this.killCount,
    runsAgo: 0,
  };
}
```

### 4. Degradation
Apply degradation based on `runsAgo` when spawning skeletons:

| runsAgo | Degradation |
|---------|-------------|
| 0 (most recent) | 75% of original stats (weapon dmg, armor def, etc.) |
| 1 | 60% |
| 2-3 | 45% |
| 4-6 | 30% |
| 7-9 | 15% â€” may lose non-weapon items entirely |

Implementation: `degradeRecord(record: SkeletonRecord): SkeletonRecord` returns
a copy with degraded stats. Items below a threshold (e.g., weapon damage < 1) are
removed. At high runsAgo, only the weapon may survive.

Degradation affects:
- `weapon.damage` â€” multiply and floor
- `armor.defense` â€” multiply and floor
- `accessory.bonuses[].value` â€” multiply and floor
- `consumable.charges` â€” reduce (min 1)
- Item rarity demoted (epicâ†’rareâ†’uncommonâ†’common) per 2 runsAgo steps

### 5. Spawn Skeletons in Dungeon
Create `src/skeleton/skeleton-spawner.ts`:

```typescript
function spawnSkeletons(
  world: World,
  map: GameMap,
  rooms: Room[],
  store: SkeletonStore,
  messages: MessageLog,
): void
```

Called from `initNewRun()` after `populateRooms()`.

**Placement**: Skeletons spawn in combat/loot rooms. The most recent skeleton goes
in a deeper room, older ones in earlier rooms. Pick a random walkable tile in the
chosen room.

**Entity creation**: Each skeleton is a standard entity with:
- `Position` â€” placed in room
- `Renderable` â€” `{ char: "ðŸ’€", color: "white" }` (or `â˜ ` â€” use a distinct glyph)
- `Health` â€” scaled from original stats: `maxHealth * degradation_multiplier`
- `Stats` â€” degraded copy of player's stats at death
- `AIControlled` â€” `{ pattern: "charger" }` (skeletons are aggressive echoes)
- `Faction` â€” `"enemy"`
- `Collidable` â€” `{ blocksMovement: true }`
- `Senses` / `Awareness` â€” standard enemy vision
- `TurnActor` â€” standard
- `Named` â€” `"Skeleton Echo"` or `"Ancient Skeleton"` for old ones
- `Inventory` / `Equipment` â€” populated with degraded item entities

For each `SkeletonItemRecord`, create a real item entity in the world with the
appropriate components (Item, Weapon/Armor/etc, Renderable). Then add to the
skeleton's Inventory and equip as indicated by `equippedSlots`.

### 6. Skeleton Naming
| runsAgo | Name |
|---------|------|
| 0 | "Your Recent Echo" |
| 1-2 | "A Fading Echo" |
| 3-5 | "A Weathered Skeleton" |
| 6-9 | "Ancient Bones" |

### 7. Game Integration
```typescript
export class Game {
  private skeletonStore = new SkeletonStore();

  private initNewRun(): void {
    this.skeletonStore.ageAll();  // increment runsAgo
    // ... existing world/map creation ...
    populateRooms(...);
    spawnSkeletons(this.world, this.map, rooms, this.skeletonStore, this.messages);
  }

  // In death handling, before showGameOver():
  const record = this.captureSkeletonRecord();
  if (record) this.skeletonStore.add(record);
}
```

### 8. Death Screen Enhancement
Add a line to `showGameOver()`:
```
Skeleton left behind with: Iron Sword, Leather Armor
```

Lists the items that will appear on the skeleton (before degradation â€” the player
sees what they lost, not what degraded to).

### 9. Message on Skeleton Discovery
When the player first sees a skeleton (enters FOV):
```
You see Your Recent Echo here... it carries an Iron Sword.
```

This creates anticipation. Implementation: check newly visible tiles for skeleton
entities and log a message. Can be a simple check in the FOW update.

## File Structure
```
src/skeleton/
  skeleton-record.ts   â€” SkeletonRecord, SkeletonItemRecord types
  skeleton-store.ts    â€” SkeletonStore class (in-memory, 10 cap)
  skeleton-spawner.ts  â€” spawnSkeletons(), degradeRecord()
```

## Edge Cases
- **Player dies with empty inventory**: create skeleton with no items, just bones.
  Still worth spawning â€” it's a landmark and has degraded stats to fight.
- **Player dies on first turn**: skeleton has starting stats, no gear. Fine.
- **All rooms full of enemies**: place skeleton in any room with space. Skip if
  truly no valid tile (shouldn't happen with current map sizes).
- **10 skeletons + new death**: oldest removed before adding new. Store handles cap.
- **Degradation reduces weapon to 0 damage**: remove the weapon from the skeleton.
  Skeleton fights with fists (0 damage + strength).
- **Item index mapping**: equippedSlots reference indices into items[]. If an item
  is removed during degradation, null out the corresponding equipped slot.

## Tests
- Unit test: SkeletonStore add/age/cap at 10
- Unit test: captureSkeletonRecord snapshots all player items and stats
- Unit test: degradeRecord at runsAgo=0 gives 75% stats
- Unit test: degradeRecord at runsAgo=5 gives 30%, drops weak items
- Unit test: spawnSkeletons creates entities with correct components
- Unit test: spawned skeleton items are real entities with Position=none, correct Weapon/Armor
- Unit test: skeleton naming matches runsAgo tiers
- Manual: die with gear, restart, find skeleton in dungeon
- Manual: skeleton carries recognizable (degraded) version of your gear
- Manual: killing skeleton drops its items (requires TODO-c2d6cdd4)
- Manual: multiple deaths create multiple skeletons
- Manual: 11th death removes oldest skeleton
- `bun test` passes

## Definition of Done
- SkeletonStore persists records across runs (in-memory, on Game instance)
- Player death captures full equipment/stats snapshot
- Degradation scales with runsAgo (75% â†’ 15%)
- Skeletons spawn in dungeon rooms with degraded gear as real entities
- Skeletons use standard AI, Faction, combat â€” no special-case code
- Death screen mentions skeleton left behind
- 10 skeleton cap enforced
- `bun test` passes
