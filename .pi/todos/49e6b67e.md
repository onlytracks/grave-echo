{
  "id": "49e6b67e",
  "title": "Dump game logs to logs/<timestamp>.log per run",
  "tags": [
    "quality-of-life",
    "debug",
    "logging"
  ],
  "status": "open",
  "created_at": "2026-02-15T06:33:22.804Z"
}

## Goal
Write all MessageLog entries (gameplay + debug) to a log file per run for post-mortem
debugging. When a run ends (death or quit), flush the full message log to
`logs/<timestamp>.log`.

## Existing Code

### MessageLog (`src/ecs/systems/messages.ts`)
- `getAllMessagesWithTurns()` returns all `TaggedMessage[]` (gameplay + debug)
- Messages have `text`, `turn`, `category`
- `maxMessages = 100` — capped in memory. **This cap needs to be raised or
  bypassed for file logging**, otherwise early-game messages are lost.

### Game Loop (`src/game.ts`)
- `initNewRun()` creates new MessageLog per run
- `showGameOver()` called on death — good hook for flush
- `run()` loop — flush on quit too

## Requirements

### 1. Raise MessageLog Cap for Debug
Increase `maxMessages` to 2000 (or remove cap) so the full run's messages survive
in memory for file dump. 2000 messages × ~100 bytes ≈ 200KB — trivial.

### 2. Log File Writer
Create `src/logging/log-writer.ts`:

```typescript
import { mkdirSync, writeFileSync } from "fs";

export function writeRunLog(messages: readonly TaggedMessage[], meta: RunMeta): void {
  mkdirSync("logs", { recursive: true });

  const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
  const filename = `logs/${timestamp}.log`;

  const header = [
    `=== Grave Echo Run Log ===`,
    `Date: ${new Date().toISOString()}`,
    `Turns: ${meta.turns}`,
    `Kills: ${meta.kills}`,
    `Result: ${meta.result}`,
    `===========================`,
    ``,
  ].join("\n");

  const lines = messages.map(m => {
    const prefix = m.category === "debug" ? "[DBG]" : "[GAM]";
    const turn = m.turn > 0 ? `T${String(m.turn).padStart(4)}` : "T   0";
    return `${turn} ${prefix} ${m.text}`;
  });

  writeFileSync(filename, header + lines.join("\n") + "\n");
}

interface RunMeta {
  turns: number;
  kills: number;
  result: "death" | "quit";
}
```

### 3. Integration Points
In `src/game.ts`:

```typescript
// After death, before showGameOver():
writeRunLog(this.messages.getAllMessagesWithTurns(), {
  turns: this.turnCounter,
  kills: this.killCount,
  result: "death",
});

// On quit from game over screen:
// (log already written on death)

// On quit during play (Esc/q):
writeRunLog(this.messages.getAllMessagesWithTurns(), {
  turns: this.turnCounter,
  kills: this.killCount,
  result: "quit",
});
```

### 4. Add `logs/` to `.gitignore`

### 5. Log Format Example
```
=== Grave Echo Run Log ===
Date: 2026-02-15T06:30:00.000Z
Turns: 47
Kills: 3
Result: death
===========================

T   0 [DBG] [spawn] Dungeon generated: 14 rooms, 120x80
T   0 [DBG] [spawn] Room tags: 0:entry(d0), 1:combat(d1), ...
T   1 [DBG] [turn] === Turn 1 ===
T   1 [DBG] [turn] Player turn start: 2 moves
T   1 [DBG] [move] Player moved to (15,10)
T   1 [DBG] [sense] Player revealed 12 new tiles
T   2 [DBG] [sense] g#5: idle → alert (spotted hostile at d=5)
T   2 [DBG] [sense] Player: idle → alert (sees alert g#5)
T   2 [GAM] Something moves nearby!
T   3 [DBG] [ai] g#5: moving toward target at (15,10)
T   3 [DBG] [combat] g#5 attacks Player for 3 damage
T   3 [GAM] The g hits you for 3 damage!
...
T  47 [GAM] You have died!
```

## Files to Change
- New: `src/logging/log-writer.ts`
- `src/ecs/systems/messages.ts` — raise maxMessages to 2000
- `src/game.ts` — call writeRunLog on death and quit
- `.gitignore` — add `logs/`

## Definition of Done
- Every run produces `logs/<timestamp>.log` with full message history
- Log includes run metadata (turns, kills, result)
- Messages prefixed with turn number and category
- `logs/` gitignored
- `bun test` passes
